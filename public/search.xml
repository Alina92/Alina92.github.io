<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redux知识点</title>
      <link href="/2021/06/20/redux%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/06/20/redux%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/redux.jpg" alt="avatar"></p><ol><li><p>store </p><p>掌管整个应用的状态, 整个应用只能有一个store。通过store.getState() 获取应用某个时间点的快照（状态），通过store.dispatch 分发action.Redux 规定： 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p></li><li><p>reducer</p><p>当store收到action ，就要生成一个新的state, 这个计算过程就是reducer。reducer是一个纯函数，即相同的输入，一定得到相同的输出。</p></li><li><p>action</p><p>用户不能直接修改state, state的变化必须是View 导致的， action 就是View 发出的一个通知，表示action 的名称。</p></li></ol><h3 id="redux-重要API"><a href="#redux-重要API" class="headerlink" title="redux 重要API"></a>redux 重要API</h3><ol><li><p>createStore函数:用来生成store。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(reducer, initialState, enhancer)</span><br></pre></td></tr></table></figure></li><li><p>bindActionCreators:将 action 包装成直接可被调用的函数，用户感知不到dispatch的存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = dispatch =&gt; bindActionCreators(actions, dispatch);</span><br><span class="line">return connect(mapStateToProps, mapDispatchToProps)(Node);</span><br></pre></td></tr></table></figure></li><li><p>combineReducers:一个复杂的应用往往state 比较庞大，导致 Reducer 函数也比较庞大，因此如果能把reducer拆分成一个个独立的子Reducer, 最后再把他们合成一个大的reducer，处理起来就比较方便。而combineReducers就是做这件事的，该函数根据state的key去执行响应的子Reducer，并将结果合并到最终的state对象里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; storeReducer &#125; from &apos;./store/reducer&apos;;</span><br><span class="line">import &#123; reserveReducer &#125; from &apos;./reserve/reducer&apos;;</span><br><span class="line"></span><br><span class="line">export const settingReducer = combineReducers(&#123;</span><br><span class="line">    store: storeReducer,</span><br><span class="line">    reserve: reserveReducer,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>applyMiddleware:applyMiddleware(…middlewares) 引入中间件，比如我们经常使用的用于处理异步action的redux-thunk 中间件。</p></li><li>compose:是一个返回依次执行参数里面的方法的函数， 其内部是通过Array.prototype.reduceRight 函数实现的，一般redux项目使用多个中间件时会用到。<h3 id="react-redux-API"><a href="#react-redux-API" class="headerlink" title="react-redux API"></a>react-redux API</h3></li><li><p>Provider:<br>Provider其实是一个React 组件，其原理是通过React组件的context 属性实现store 的传递， 进而拿到整个应用的state。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const App = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Comp/&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>connect:函数是把 redux 的 dispatch 和 state 映射为 react 组件的 props中，将页面里的组件与应用的状态state真正连接起来。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (state, ownProps) =&gt; &#123;</span><br><span class="line">  // state 是 &#123;userList: [&#123;id: 0, name: &apos;王二&apos;&#125;]&#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    user: _.find(state.userList, &#123;id: ownProps.userId&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    increase: (...args) =&gt; dispatch(actions.increase(...args)),</span><br><span class="line">    decrease: (...args) =&gt; dispatch(actions.decrease(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyComp extends Component &#123;</span><br><span class="line">static PropTypes = &#123;</span><br><span class="line">      userId: PropTypes.string.isRequired,</span><br><span class="line">      user: PropTypes.object</span><br><span class="line">    &#125;;</span><br><span class="line">    render()&#123;</span><br><span class="line">      const &#123;count, increase, decrease&#125; = this.props;</span><br><span class="line">      return (&lt;div&gt;</span><br><span class="line">        &lt;div&gt;用户名：&#123;this.props.user.name&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;计数：&#123;this.props.count&#125;次&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;increase&#125;&gt;增加&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;decrease&#125;&gt;减少&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);</span><br></pre></td></tr></table></figure><p>   使用middleWare背景：我们知道redux中数据流是同步的，不支持异步action更新或获取数据，但是在实际项目中异步请求数据绝对是高频出现，并且可以说占据了9成以上的业务场景（初始数据列表、获取商品信息、添加购物车等等），因此redux中间件诞生了</p><h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h3><p>   redux-saga 就是用来处理上述副作用（异步任务）的一个中间件。它是一个接收事件，并可能触发新事件的过程管理者，为你的应用管理复杂的流程.<br>redux-saga 的优点：<br>（1）声明式 Effects：所有的操作以JavaScript对象的方式被 yield，并被 middleware 执行。使得在 saga 内部测试变得更加容易，可以通过简单地遍历 Generator 并在 yield 后的成功值上面做一个 deepEqual 测试。<br>（2）高级的异步控制流以及并发管理：可以使用简单的同步方式描述异步流，并通过 fork 实现并发任务。<br>（3）架构上的优势：将所有的异步流程控制都移入到了 sagas，UI 组件不用执行业务逻辑，只需 dispatch action 就行，增强组件复用性。</p><h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p>redux-thunk 的主要思想是扩展 action，使得 action 从一个对象变成一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// redux-thunk example</span><br><span class="line">import &#123;applyMiddleware, createStore&#125; from &apos;redux&apos;;</span><br><span class="line">import axios from &apos;axios&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123; fetching: false, fetched: false, users: [], error: null &#125;</span><br><span class="line">const reducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &apos;FETCH_USERS_START&apos;: &#123;</span><br><span class="line">            return &#123;...state, fetching: true&#125; </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &apos;FETCH_USERS_ERROR&apos;: &#123;</span><br><span class="line">            return &#123;...state, fetching: false, error: action.payload&#125; </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &apos;RECEIVE_USERS&apos;: &#123;</span><br><span class="line">            return &#123;...state, fetching: false, fetched: true, users: action.payload&#125; </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return state;</span><br><span class="line">&#125;</span><br><span class="line">const middleware = applyMiddleware(thunk);</span><br><span class="line"></span><br><span class="line">// store.dispatch(&#123;type: &apos;FOO&apos;&#125;);</span><br><span class="line">// redux-thunk 的作用即是将 action 从一个对象变成一个函数</span><br><span class="line">store.dispatch((dispatch) =&gt; &#123;</span><br><span class="line">    dispatch(&#123;type: &apos;FETCH_USERS_START&apos;&#125;);</span><br><span class="line">    // do something async</span><br><span class="line">    axios.get(&apos;http://rest.learncode.academy/api/wstern/users&apos;)</span><br><span class="line">        .then((response) =&gt; &#123;</span><br><span class="line">            dispatch(&#123;type: &apos;RECEIVE_USERS&apos;, payload: response.data&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">            dispatch(&#123;type: &apos;FECTH_USERS_ERROR&apos;, payload: err&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>redux-thunk 的缺点：<br>（1）action 虽然扩展了，但因此变得复杂，后期可维护性降低；<br>（2）thunks 内部测试逻辑比较困难，需要mock所有的触发函数；<br>（3）协调并发任务比较困难，当自己的 action 调用了别人的 action，别人的 action 发生改动，则需要自己主动修改；<br>（4）业务逻辑会散布在不同的地方：启动的模块，组件以及thunks内部。</p>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大美新疆</title>
      <link href="/2021/03/21/%E5%A4%A7%E7%BE%8E%E6%96%B0%E7%96%86/"/>
      <url>/2021/03/21/%E5%A4%A7%E7%BE%8E%E6%96%B0%E7%96%86/</url>
      
        <content type="html"><![CDATA[<p>Day1：北京–乌鲁木齐–国际大巴扎</p><p>Day2：乌鲁木齐-五彩浅谈-住宿布尔津</p><p>Day3：布尔津-喀纳斯-登钓鱼台-住喀纳斯景区小木屋</p><p>Day4：七点起来看晨雾-回游客中心吃早饭-徒步三湾-下午去禾木村-白桦林</p><p>Day5：预计看日出（第一缕阳光）由于下雪没阳光，下午出发去布尔津的魔鬼城，到那刚好下午七点，风沙也大，没进去，门口待了回看了看夕阳，本想第二天一早来</p><p>Day6：赛里木湖-住宿清水河（薰衣草基地）</p><p>Day7：清水河-巴音布鲁克草原</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大美新疆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react+ant design</title>
      <link href="/2021/02/03/react-ant-design/"/>
      <url>/2021/02/03/react-ant-design/</url>
      
        <content type="html"><![CDATA[<h3 id="使用react-ant-design-d3-构建自己的项目"><a href="#使用react-ant-design-d3-构建自己的项目" class="headerlink" title="使用react+ant design+d3 构建自己的项目"></a>使用react+ant design+d3 构建自己的项目</h3><p>  1.先装脚手架<br><br>  注意：如果您以前create-react-app通过进行了全局安装npm install -g create-react-app，建议您使用npm uninstall -g create-react-app或卸载软件包，yarn global remove create-react-app以确保npx始终使用最新版本。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnpm install create-react-app</span><br><span class="line">create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>2.下载依赖<br><br>1.1  -S就是–save的简写,将包的名称及版本号放在package.json的dependencies里面;（elementui、echarts这些插件在实际运行中也是需要的）<br><br>1.2  -D就是–save-dev 这样安装的包的名称及版本号就会存的devDependencies（开发环境下如babel，sass-loader，gulp、babel、webpack这些压缩代码、打包的工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S dager-d3 d3 ant-design</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> create-react-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上安装 Windows10</title>
      <link href="/2020/07/01/Mac%E4%B8%8A%E5%AE%89%E8%A3%85Windows10/"/>
      <url>/2020/07/01/Mac%E4%B8%8A%E5%AE%89%E8%A3%85Windows10/</url>
      
        <content type="html"><![CDATA[<h3 id="1-查看你的Mac是不是支持Windows10系统-传送门"><a href="#1-查看你的Mac是不是支持Windows10系统-传送门" class="headerlink" title="1.查看你的Mac是不是支持Windows10系统 传送门"></a>1.查看你的Mac是不是支持Windows10系统 <a href="https://support.apple.com/zh-cn/HT201468" target="_blank" rel="noopener">传送门</a></h3><h3 id="2-安装教程-传送门"><a href="#2-安装教程-传送门" class="headerlink" title="2.安装教程 传送门"></a>2.安装教程 <a href="https://www.jianshu.com/p/b499bcc48127" target="_blank" rel="noopener">传送门</a></h3><h3 id="3-安装之后缺少wifi驱动：下载驱动精灵网卡版，用U盘拷到windows系统，解决电脑联网问题"><a href="#3-安装之后缺少wifi驱动：下载驱动精灵网卡版，用U盘拷到windows系统，解决电脑联网问题" class="headerlink" title="3.安装之后缺少wifi驱动：下载驱动精灵网卡版，用U盘拷到windows系统，解决电脑联网问题"></a>3.安装之后缺少wifi驱动：下载驱动精灵网卡版，用U盘拷到windows系统，解决电脑联网问题</h3><h3 id="4-蓝牙找不到的修复方法（右下角蓝牙模块很容易消失，在控制面板里也找不到，设备管理器里也可能找不到）："><a href="#4-蓝牙找不到的修复方法（右下角蓝牙模块很容易消失，在控制面板里也找不到，设备管理器里也可能找不到）：" class="headerlink" title="4.蓝牙找不到的修复方法（右下角蓝牙模块很容易消失，在控制面板里也找不到，设备管理器里也可能找不到）："></a>4.蓝牙找不到的修复方法（右下角蓝牙模块很容易消失，在控制面板里也找不到，设备管理器里也可能找不到）：</h3><p><img src="/images/bluetooth1.png" alt="upload successful"><br><img src="/images/bluetooth2.png" alt="upload successful"><br><img src="/images/bluetooth3.png" alt="upload successful"></p><h3 id="5-双系统切换（默认）启动-传送门"><a href="#5-双系统切换（默认）启动-传送门" class="headerlink" title="5.双系统切换（默认）启动 传送门"></a>5.双系统切换（默认）启动 <a href="https://www.jianshu.com/p/feefa410f199" target="_blank" rel="noopener">传送门</a></h3><h3 id="6-默认系统是windows企业版"><a href="#6-默认系统是windows企业版" class="headerlink" title="6.默认系统是windows企业版"></a>6.默认系统是windows企业版</h3>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> window10 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript</title>
      <link href="/2020/06/02/typescript/"/>
      <url>/2020/06/02/typescript/</url>
      
        <content type="html"><![CDATA[<p>接口（interface）和类型别名（type alias）interface只能定义对象类型，type声明的方式可以定义组合类型，交叉类型和原始类型。如果用type alias 声明的方式，会导致一些功能的缺失。</p><ol><li>interface方式可以实现接口的extends/implements，而type 不行</li><li>interface可以实现接口的merge，但是type不行</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/05/31/%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/31/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort1(arr)&#123;</span><br><span class="line">for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">for(var j=0;j&lt;arr.length-i-1;j++)&#123;</span><br><span class="line">if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">      var val=arr[j];</span><br><span class="line">                  arr[j]=arr[j+1];</span><br><span class="line">      arr[j+1]=val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return arr</span><br><span class="line">&#125;</span><br><span class="line">  console.log(bubbleSort1([4,5,21,5,4,1,12,5,4,1,2])）</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var bubbleSort2=function(arr)&#123;  </span><br><span class="line">    for(var i=0;i&lt;arr.length-1;i++)&#123;  </span><br><span class="line">        for(var j=i+1;j&lt;arr.length;j++)&#123;  </span><br><span class="line">            if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                var temp=arr[i];  </span><br><span class="line">                arr[i]=arr[j];  </span><br><span class="line">                arr[j]=temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    return arr;  </span><br><span class="line">&#125;  </span><br><span class="line">console.log(bubbleSort2([4,5,21,5,4,1,12,5,4,1,2]))</span><br></pre></td></tr></table></figure><h3 id="解析地址栏参数"><a href="#解析地址栏参数" class="headerlink" title="解析地址栏参数"></a>解析地址栏参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var url = &quot;http://www.taobao.com/index.php?key0=0&amp;key1=1&amp;key2=2&quot;;</span><br><span class="line"></span><br><span class="line"> function parseQueryString(url)&#123;</span><br><span class="line">     var str = url.split(&quot;?&quot;)[1];   //通过?得到一个数组,取?后面的参数</span><br><span class="line">         items = str.split(&quot;&amp;&quot;); </span><br><span class="line">          var arr,name,value;</span><br><span class="line">        for(var i=0; i&lt;items.length; i++)&#123;</span><br><span class="line">            arr = items[i].split(&quot;=&quot;);    //[&quot;key0&quot;, &quot;0&quot;]</span><br><span class="line">            name = arr[0];</span><br><span class="line">            value = arr[1];</span><br><span class="line">            this[name] = value;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.quchong=function()&#123;</span><br><span class="line">var arr=[];</span><br><span class="line">var json=&#123;&#125;;</span><br><span class="line">for(var i=0;i&lt;this.length;i++)&#123;</span><br><span class="line">if(!json[this[i]])&#123;</span><br><span class="line">arr.push(this[i]);</span><br><span class="line">json[this[i]]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">          return arr</span><br><span class="line">&#125;</span><br><span class="line">var arr1 = [112,112,34,&apos;你好&apos;,112,112,34,&apos;你好&apos;,&apos;str&apos;,&apos;str1&apos;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2020/05/28/git/"/>
      <url>/2020/05/28/git/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/git_1.png" alt="upload successful"><br><img src="/images/git_2.png" alt="upload successful"><br><img src="/images/git.png" alt="upload successful"></p><ol><li>git add :作用就是将我们需要提交的代码从工作区添加到暂存区</li><li>git commit:主要是将暂存区里的改动给提交到本地的版本库</li><li>git push:将本地版本库推送到远程服务器</li><li>git pull:将更改从远程应用到本地</li></ol><ul><li>git diff:显示暂存区和工作区的代码差异</li><li>git diff HEAD:显示工作区与当前分支最新commit之间的差异</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2020/05/27/axios/"/>
      <url>/2020/05/27/axios/</url>
      
        <content type="html"><![CDATA[<p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><ol><li><p>执行 GET 请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 为给定 ID 的 user 创建请求</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 上面的请求也可以这样做</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>执行 POST 请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>全局的 axios 默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure></li><li><p>自定义实例默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建实例时设置配置的默认值</span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">  baseURL: &apos;https://api.example.com&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 在实例已创建后修改默认值</span><br><span class="line">instance.defaults.headers.common[&apos;Authorization&apos;] = localStorage.getItem(&quot;token&quot;);</span><br></pre></td></tr></table></figure></li><li><p>添加Token：token是客户端频繁向服务器端请求数据，服务器频繁的去数据库查询用户名和密码进行对比，判断用户名和密码正确与否，并作出相应的提示，在这样的背景下，token便应运而生了。</p><ul><li>登录后接口返回token，并使用localStorage保存token</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var ecpkey = genrKey(timestamp, num, options.url);</span><br><span class="line">     return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">         const instance = axios.create(&#123; //instance创建一个axios实例，可以自定义配置，可在 axios文档中查看详情</span><br><span class="line">             //所有的请求都会带上这些配置，比如全局都要用的身份信息等。</span><br><span class="line">             headers: &#123;</span><br><span class="line">                 &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">                 &apos;timestamp&apos;: timestamp + &quot;-&quot; + num,</span><br><span class="line">                 &apos;ecpkey&apos;: ecpkey,</span><br><span class="line">                 &apos;token&apos;: localStorage.getItem(&quot;token&quot;)</span><br><span class="line">             &#125;,</span><br><span class="line">             //后面数组中的函数必须返回一个字符串</span><br><span class="line">             transformRequest: [function (data) &#123;</span><br><span class="line">                 return Qs.stringify(data);</span><br><span class="line">             &#125;]</span><br><span class="line">         &#125;);</span><br><span class="line">         instance(options)</span><br><span class="line">             .then(response =&gt; &#123; //then 请求成功之后进行什么操作</span><br><span class="line">                 if (response.status === 200) &#123;</span><br><span class="line">                     if (response.data.accCheck === &quot;1&quot;) &#123;</span><br><span class="line">                         localStorage.clear();</span><br><span class="line">                         sessionStorage.clear();</span><br><span class="line">                         store.commit(&apos;login&apos;, false);</span><br><span class="line">                         router.push(&#123;</span><br><span class="line">                             path: &apos;/&apos;</span><br><span class="line">                         &#125;);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     resolve(response); //把请求到的数据发到引用请求的地方</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">             .catch(err =&gt; &#123;</span><br><span class="line">                 if(options.url==&apos;/user/logout&apos;)&#123;</span><br><span class="line">                     localStorage.clear();</span><br><span class="line">                     sessionStorage.clear();</span><br><span class="line">                     router.push(&#123;</span><br><span class="line">                         path:&quot;/&quot;</span><br><span class="line">                     &#125;)</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">、</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总结</title>
      <link href="/2020/05/26/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
      <url>/2020/05/26/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="箭头函数于普通函数的区别"><a href="#箭头函数于普通函数的区别" class="headerlink" title="箭头函数于普通函数的区别"></a>箭头函数于普通函数的区别</h3><ol><li><p>函数的this代表不一样：</p><ul><li><p>箭头函数，this代表上层对象，若无自定义上层，则代表window。 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()，call()和apply()都会立即执行，而bind()会先创建一个函数实例，然后手动的去执行；</p><ul><li>函数.call(对象,arg1,arg2….)</li><li>函数.apply(对象，[arg1,arg2,…])</li><li>var ss=函数.bind(对象,arg1,arg2,….)</li></ul></li><li><p>普通函数，this代表当前对象。</p></li></ul></li></ol><h3 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h3><ol><li>var声明变量存在变量提升，let和const不存在变量提升</li><li>let和const有块级作用域</li><li>同一作用域下let和const不能声明同名变量，而var可以</li></ol><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><ul><li><p>浅拷贝</p><ol><li>Object.assign()</li><li>Array.prototype.concat() //修改新对象会改到原对象</li><li>Array.prototype.slice() //修改新对象会改到原对象</li></ol><ul><li>【Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组】</li></ul></li><li><p>深拷贝</p><ol><li>函数库lodash中的_.cloneDeep</li><li>JSON.parse(JSON.stringify()) *<a href="https://blog.csdn.net/xiaokanfuchen86/article/details/106149171/" target="_blank" rel="noopener">详细地址</a><ul><li>深拷贝的方法有局限性，它只适用于一般数据的拷贝（对象、数组）</li><li>如果json里面有时间对象，则序列化结果：时间对象=&gt;字符串的形式</li><li>如果json里有RegExp、Error对象，则序列化的结果将只得到空对象 RegExp、Error =&gt; {}</li><li>如果json里有 function,undefined，则序列化的结果会把 function,undefined 丢失</li><li>如果json里有NaN、Infinity和-Infinity，则序列化的结果会变成null；</li><li>如果json里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor；</li></ul></li></ol></li></ul><h3 id="map，forEach，-for…in，-for…of"><a href="#map，forEach，-for…in，-for…of" class="headerlink" title="map，forEach， for…in， for…of"></a>map，forEach， for…in， for…of</h3><ol><li>map：返回一个新数组，它不会检测一个空数组，也不会改变原始数组</li><li>forEach：不会返回结果，必须要通过外部数组push，对数组进行值操作，会改变原来数组的值</li><li>for…in：循环返回的值都是数据结构的 键值名。</li><li>for…of：循环用来获取一对键值对中的值，这个是ES6新增的一个方法，不支持数组，可以中断循环</li></ol><h3 id="typeof-instanceof"><a href="#typeof-instanceof" class="headerlink" title="typeof instanceof"></a>typeof instanceof</h3><p>1.typeof：判断基本类型类型（number, string, undefined，boolean）,array,object,正则，日期等类型返回’object’<br>2.instanceof：用于判断一个变量是否某个对象的实例</p><h3 id="js中递归，闭包"><a href="#js中递归，闭包" class="headerlink" title="js中递归，闭包"></a>js中递归，闭包</h3><ul><li><p>递归：一个函数自己调用自己，递归应用场景(累加和，阶乘)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //1.求1-n之间的累加和</span><br><span class="line">    function getSum(n)&#123;</span><br><span class="line">        //递归 ： 自己调用自己</span><br><span class="line">        return n == 1? 1 : getSum(n-1) + n;</span><br><span class="line">        // if(n == 1)&#123;</span><br><span class="line">        //     return 1;</span><br><span class="line">        // &#125;else&#123;</span><br><span class="line">        //     return getSum(n-1) + n;</span><br><span class="line">        // &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    var num1 = getSum(100);</span><br><span class="line">    console.log(num1);</span><br><span class="line">   </span><br><span class="line">//2.求阶乘</span><br><span class="line">    var res = (function(n)&#123;return n==1?1:n*arguments.callee(n-1)&#125;)(6);</span><br><span class="line">    console.log(res);</span><br><span class="line"></span><br><span class="line">    function getJieChen(n)&#123;</span><br><span class="line">        //递归实现</span><br><span class="line">        return n == 1?1:n*getJieChen(n-1);  </span><br><span class="line">    &#125;;</span><br><span class="line">    var n1 = getJieChen(5);</span><br><span class="line">    console.log(n1);</span><br></pre></td></tr></table></figure></li><li><p>闭包：在函数外部访问函数内部变量</p><h3 id="reduce与递归将多维数组转换为一维数组"><a href="#reduce与递归将多维数组转换为一维数组" class="headerlink" title="reduce与递归将多维数组转换为一维数组"></a>reduce与递归将多维数组转换为一维数组</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//将二维数组转化为一维</span><br><span class="line">  let arr = [[0, 1], [2, 3], [4, 5]]</span><br><span class="line">  let newArr = arr.reduce((pre,cur)=&gt;&#123;</span><br><span class="line">      return pre.concat(cur)</span><br><span class="line">  &#125;,[])</span><br><span class="line">  console.log(newArr); // [0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">//将多维数组转化为一维</span><br><span class="line">  let arr = [[0, 1], [2, 3], [4,[5,6,7]]]</span><br><span class="line">  const newArr = function(arr)&#123;</span><br><span class="line">     return arr.reduce((pre,cur)=&gt;pre.concat(Array.isArray(cur)?newArr(cur):cur),[])</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line">  //递归</span><br><span class="line">  let arr = [1, 2, 3, 4, 5, [6, 7, 8, [9, 10, 11, 12, [13, 14, 15, 16]]]]</span><br><span class="line">  let newArr = [] // 存放转化后的一维数组</span><br><span class="line">  function arrConversion (arr) &#123;</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (Array.isArray(arr[i])) &#123;</span><br><span class="line">        arrConversion(arr[i])</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        newArr.push(arr[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arrConversion(arr)</span><br><span class="line">  console.log(newArr) // 输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><br></pre></td></tr></table></figure><h3 id="Html5新增"><a href="#Html5新增" class="headerlink" title="Html5新增"></a>Html5新增</h3><ol><li>语义化标签：header,footer,nav,aside,aritcle等</li><li>新增视频video和音频audio标签</li><li>存储：sessionStorage将数据保存在session中，浏览器关闭后删除，大小5M，无数量限制，页面刷新不会消除数据；而localStorage则一直将数据保存在客户端本地，大小5M，无数量限制；补充cookie，存储在本地的数据，存储大小4K，可设定时效，且有数量限制；IE专属userData，大小1M，可设定时效，使用时需判断是否是IE浏览器</li></ol><h3 id="CSS权重"><a href="#CSS权重" class="headerlink" title="CSS权重"></a>CSS权重</h3><p>从0开始，一个行内样式+1000，一个id+100，一个属性选择器/class或者伪类+10，一个元素名，或者伪元素+1，!important是无穷。</p><h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3><ol><li>animation配合keyframes使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  width:100px;</span><br><span class="line">  height:100px;</span><br><span class="line">  background:red;</span><br><span class="line">  position:relative;</span><br><span class="line">  animation:myfirst 5s;</span><br><span class="line">  -moz-animation:myfirst 5s; /* Firefox */</span><br><span class="line">  -webkit-animation:myfirst 5s; /* Safari and Chrome */</span><br><span class="line">  -o-animation:myfirst 5s; /* Opera */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  0%   &#123;background:red; left:0px; top:0px;&#125;</span><br><span class="line">  25%  &#123;background:yellow; left:200px; top:0px;&#125;</span><br><span class="line">  50%  &#123;background:blue; left:200px; top:200px;&#125;</span><br><span class="line">  75%  &#123;background:green; left:0px; top:200px;&#125;</span><br><span class="line">  100% &#123;background:red; left:0px; top:0px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>transform 字面上就是变形，属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行translate平移、rotate旋转、scale缩放、skew斜切。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.translate有2个参数，代表x轴和y轴, 只有1个参数时，只在x轴移动，y轴默认是0；transform: translate(10px,10px)</span><br><span class="line">2.rotate(1800deg)参数值为正数顺时针旋转，值为负数逆时针旋转； transform:rotate(90deg)</span><br><span class="line">3.scale(x,y)  x轴和y轴缩放，第二个参数没有默认取第一个参数的值，scale(0.5)参数值小于1缩小，scale(1.5)参数值大于1放大； transform:scale(1.2)</span><br><span class="line">4.skew(x,y) 斜切 用法和rotate类似，在x轴和y轴同时进行角度扭曲，第二个参数没有时默认为0，不进行斜切； transform: skew(90deg,10deg)</span><br></pre></td></tr></table></figure><ol start="3"><li>transition有4个值（默认是前2个值）：property(指定css属性的name)、duration（动画持续时间）、timing-function(切换动画的速度)、delay(动画执行前的延迟时间)</li></ol><p>flex布局<br>媒体查询</p><h3 id="less和sass"><a href="#less和sass" class="headerlink" title="less和sass"></a>less和sass</h3><ol><li>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展，它可以运行在 Node 或浏览器端。</li><li>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 、嵌套 、混合  、导入  等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass  的样式库（如Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</li><li><p>相同之处</p><p>1、混入(Mixins)——class中的class；</p><p>2、参数混入——可以传递参数的class，就像函数一样；</p><p>3、嵌套规则——Class中嵌套class，从而减少重复的代码；</p><p>4、运算——CSS中用上数学；</p><p>5、颜色功能——可以编辑颜色；</p><p>6、名字空间(namespace)——分组样式，从而可以被调用；</p><p>7、作用域——局部修改样式；</p><p>8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。</p></li><li><p>区别</p><p>Less是基于JavaScript，是在客户端处理的。</p><p>Sass是基于Ruby的，是在服务器端处理的。</p><p>关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</p><p>输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。</p><p>Sass支持条件语句，可以使用if{}else{},for{}循环等等，而Less不支持。</p></li></ol><h3 id="输入url到页面加载发生了什么"><a href="#输入url到页面加载发生了什么" class="headerlink" title="输入url到页面加载发生了什么"></a>输入url到页面加载发生了什么</h3><ol><li>用户输入”吴彦祖”</li><li>浏览器通过DNS把url解析为IP</li><li>和IP地址建立TCP链接，发送Http请求</li><li>服务器接收请求，查库读取文件等，拼接好返回Http响应</li><li>浏览器收到首屏html，开始渲染</li><li>解析html为dom，dom-tree</li><li>解析css为css-tree</li><li>dom+css生成render-tree绘图</li><li>加载script文件</li><li>执行js</li></ol><h3 id="从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程"><a href="#从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程" class="headerlink" title="从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程"></a>从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程</h3><ol><li>用户输入<br>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。</li><li><p>URL 请求过程</p><p>首先，网络进程会查找本地缓存是否缓存了该资源。</p><p>如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p><p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。</p><p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。</p><p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。</p><p>其中，DNS也有几步缓存：浏览器缓存，hosts文件，<br>如果本地域名解析服务器也没有该域名的记录，则开始递归+迭代解析<br>TCP三次握手，HTTP。TLS握手，HTTPS。</p></li><li><p>准备渲染进程</p><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。</p></li><li><p>渲染阶段</p><p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有CSS的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p><p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。</p><p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p><p>在生成 Render 树的过程中，浏览器就开始调用GPU 绘制，合成图层，将内容显示在屏幕上了。</p></li></ol><h3 id="eventloop机制，promise的实现和静态方法、async实现"><a href="#eventloop机制，promise的实现和静态方法、async实现" class="headerlink" title="eventloop机制，promise的实现和静态方法、async实现"></a>eventloop机制，promise的实现和静态方法、async实现</h3><ol><li>Event Loop 是什么？<br>js的任务队列分为同步任务和异步任务，所有的同步任务都是在主线程里执行的，异步任务可能会在宏任务或者微任务里面。</li><li>JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)<ul><li>宏任务：包括整体代码script，setTimeout，setInterval</li><li>微任务：Promise.then(非new Promise)，process.nextTick(node中)</li><li>事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。</li></ul></li></ol><h3 id="浏览器页签间通信"><a href="#浏览器页签间通信" class="headerlink" title="浏览器页签间通信"></a>浏览器页签间通信</h3><ol><li>localStorage —— 使用addeventlistene舰艇storage事件</li><li>cookie+setInterval —— cookie存储数据，定时器在一定间隔获取cookie数据</li><li>websocket通讯 —— html5中的协议，基于http协议，完成部分握手动作，完成双向通信功能，支持持久连接。</li><li>sharedWorker —— 必须运行在服务器上</li></ol><h3 id="ES6中的map和set"><a href="#ES6中的map和set" class="headerlink" title="ES6中的map和set"></a>ES6中的map和set</h3><p><a href="https://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/set-map</a></p><ol><li>Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</li><li>Maps 和 Objects 的区别<br>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。<br>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li><li>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</li></ol><h3 id="Promise-和-async-await"><a href="#Promise-和-async-await" class="headerlink" title="Promise 和 async/await"></a>Promise 和 async/await</h3><p>对于单一的 Promise 链其实并不能发现 async/await 的优势，当需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了</p><ol><li>promise是ES6，async/await是ES7</li><li>async/await相对于promise来讲，写法更加优雅</li><li>reject状态：<br> 1）promise错误可以通过catch来捕捉，建议尾部捕获错误，<br> 2）async/await既可以用.then又可以用try-catch捕捉</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>react知识点</title>
      <link href="/2020/05/25/react%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/05/25/react%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="15-x生命周期"><a href="#15-x生命周期" class="headerlink" title="15.x生命周期"></a>15.x生命周期</h3><p><img src="/images/react15.jpg" alt="avatar"></p><ol><li>挂载卸载过程<br>1.1 constructor()<br>1.2 componentWillMount()<br>1.3 componentDidMount()<br>1.4 componentWillUnmount ()</li><li>更新过程<br>2.1 componentWillReceiveProps (nextProps)<br>2.2 shouldComponentUpdate(nextProps,nextState)<br>2.3 componentWillUpdate (nextProps,nextState)<br>2.4 componentDidUpdate(prevProps,prevState)<br>2.5 render()</li></ol><h3 id="16-x生命周期"><a href="#16-x生命周期" class="headerlink" title="16.x生命周期"></a>16.x生命周期</h3><p><img src="/images/react16.jpg" alt="avatar"><br>React新增的生命周期(个人补充)</p><ol><li>getDerivedStateFromProps(nextProps, prevState)</li><li>getSnapshotBeforeUpdate(prevProps, prevState)</li></ol><h3 id="super（props）"><a href="#super（props）" class="headerlink" title="super（props）"></a>super（props）</h3><pre><code>super(props)的作用就是在父类的构造函数中给props赋值一个对象this.props=props这样就能在它的下面定义你要用到的属性了，然而其他的由于没有传参就直接赋值为undefind</code></pre><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><ol><li>setstate在原生事件，setTimeout,setInterval,promise等异步操作中，state会同步更新，在React内部机制能检测到的地方， setState就是异步的。</li><li>在异步的函数里可以准确拿到更新后的 state，通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。</li></ol><h3 id="key为index的问题"><a href="#key为index的问题" class="headerlink" title="key为index的问题"></a>key为index的问题</h3><p><strong>注意：如果不存在添加/删除/排序操作, 用index没有问题</strong></p><ol><li>添加/删除/排序 =&gt; 产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低</li><li>如果item界面还有输入框 =&gt; 产生错误的真实DOM更新 ==&gt; 界面有问题</li></ol><p><strong>解决：使用item数据的标识数据作为key, 比如id属性值</strong></p><h3 id="数据传递详情"><a href="#数据传递详情" class="headerlink" title="数据传递详情"></a>数据传递<a href="https://www.cnblogs.com/jpwz/p/12411804.html" target="_blank" rel="noopener">详情</a></h3><ol><li>父传子：props</li><li>子传父：子组件中通过this.props.事件名(参数)的方式向父组件传递参数，父组件中，事件名={this.事件名.bind(this)}</li><li>兄弟（组件A – 传值 –&gt; 父组件 – 传值 –&gt; 组件B）<br><img src="/images/brother.jpg" alt="avatar"></li></ol><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>为了减少消耗性能的DOM操作，React 把真实 DOM 树转换成js对象树，也就是 Virtual DOM。每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做Diff计算对比，对发生 变化的部分做批量更新。</p><ul><li>当首次挂载组件时，按顺序执行 getDefaultProps、getInitialState、componentWillMount、 render 和 componentDidMount。</li><li>当卸载组件时，执行 componentWillUnmount。</li><li>当重新挂载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和componentDidMount，但并不执行 getDefaultProps。</li><li>当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。</li></ul><p>同一层级的子节点，可以通过唯一的 id 来进行区分，通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。</p><h3 id="super-props"><a href="#super-props" class="headerlink" title="super(props)"></a>super(props)</h3><p>super(props)的作用就是在父类的构造函数中给props赋值一个对象this.props=props这样就能在它的下面定义你要用到的属性了，然而其他的由于没有传参就直接赋值为undefind，如果不写，某个构造函数中调用了某个访问props的方法，bug就很难定位了，强烈建议使用。</p><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>默认情况下，会对props和state进行浅比较，如果组件渲染过程中，新旧props和state是相等的，将不会执行render，不能使用shouldComponentUpdate方法</p><h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p><a href="https://mp.weixin.qq.com/s/06GDG6mdaElTfzb5McMxFQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/06GDG6mdaElTfzb5McMxFQ</a><br><a href="https://blog.csdn.net/qq_42941302/article/details/111834035" target="_blank" rel="noopener">https://blog.csdn.net/qq_42941302/article/details/111834035</a></p><p>在Rudux中因为深拷贝对性能的消耗太大了（用到了递归，逐层拷贝每个节点）。<br>但当你使用immutable数据的时候：只会拷贝你改变的节点，从而达到了节省性能。</p><h3 id="React函数组件和类组件的区别"><a href="#React函数组件和类组件的区别" class="headerlink" title="React函数组件和类组件的区别"></a>React函数组件和类组件的区别</h3><ol><li>函数组件是一个纯函数，不能在组件中使用setState()，不能在函数组件中使用生命周期钩子，原因和不能使用state一样，所有的生命周期钩子都来自于继承的React.Component中。但是在react16.8版本中添加了hooks，使得我们可以在函数组件中使用useState钩子去管理state，使用useEffect钩子去使用生命周期函数。</li><li>类组件存在this指向的问题（使用bind(this)提前规避）</li><li>函数组件不会被实例化，整体渲染性能得到提升</li></ol><h3 id="setState是同步还是异步"><a href="#setState是同步还是异步" class="headerlink" title="setState是同步还是异步"></a>setState是同步还是异步</h3><p>setState 只在合成事件和钩子函数中是“异步”的（在组件中的onClick，生命周期函数或等都是属于它自定义的合成事件）；在原生事件和 setTimeout 中都是同步的（addeventListener添加的，dom中的原生事件）。</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><ol><li>useState<br> const [state, setState] = useState(initialState);</li><li>useEffect<br> 2.1 当useEffect没有第二个参数时，相当于componentDidMount以及componentDidUpdate<br> 2.2 空数组，初始化调用一次之后不再执行，相当于componentDidMount<br> 2.3 一个或者多个值的数组，值其中任意一个值变化了都会触发该函数，相当于componentDidUpdate<br> 2.4 返回一个函数，相当于componentWillUnmout（return中）<h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3>用函数包裹，函数参数接受一个普通组件，并最终返回一个新组件，这个返回的新组件就叫做高阶组件<h3 id="react-vue-区别"><a href="#react-vue-区别" class="headerlink" title="react vue 区别"></a>react vue 区别</h3></li><li>监听数据变化的实现原理不同<br>Vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化。</li></ol><p>React默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。为什么React不精确监听数据变化呢？这是因为Vue和React设计理念上的区别，Vue使用的是可变数据，而React更强调数据的不可变，两者没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。</p><ol start="2"><li>数据流的不同<br>Vue1.0中可以实现两种双向绑定：父子组件之间，props可以双向绑定；组件与DOM之间可以通过v-model双向绑定。Vue2.x中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且Vue2.x已经不鼓励组件对自己的 props进行任何修改了。</li></ol><p>React一直不支持双向绑定，提倡的是单向数据流，称之为onChange/setState()模式。不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</p><p>相同点： </p><ol><li><p>使用 虚拟DOM (Virtual DOM)</p><p>为什么Virtual DOM的能提高页面渲染性能？<br>Virtual DOM是一个映射真实DOM的JavaScript对象<br>如果需要改变任何元素的状态，那么首先在Virtual DOM上进行改变（而不是直接改变真实的DOM）<br>然后，计算新旧Virtual DOM之间的差别（算法）<br>最后，根据这些差别对真实的DOM增加、删除、修改、移动。</p></li><li><p>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</p></li><li><p>中心思想相同：一切都是组件，组件实例之间可以嵌套。</p></li><li><p>每个组件都提供合理的钩子函数，可以让开发者定制化地去处理需求。</p></li><li><p>专注于核心库，而将其他功能如路由和全局状态管理交给相关的库。<br>不同点</p></li><li><p>数据绑定： 单向、双向<br>React: 基于JSX编码, 单向数据绑定, 不能直接更新状态数据，必须通过setState()更新指定数据<br>Vue: 基于模板语法, 双向数据绑定, 直接更新data数据11.35. Vue中mixin与extend区别</p></li><li><p>模板管理：JSX、template模版<br>Vue所有的模板使用的是近似常规HTML，只不过是新添加了一些属性</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2020/05/24/Vuex/"/>
      <url>/2020/05/24/Vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="vuex五个核心概念"><a href="#vuex五个核心概念" class="headerlink" title="vuex五个核心概念"></a>vuex五个核心概念</h3><ol><li>state:vuex的基本数据，用来存储变量</li><li>getters:从基本数据(state)派生的数据，相当于state的计算属性</li><li>mutations:提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</li><li>actions:和mutation的功能大致相同，不同之处在于 ==》*Action 提交的是 mutation，而不是直接变更状态。  Action 可以包含任意异步操作</li><li>modules:模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。<br><img src="/images/vuex.png" alt="avatar"></li></ol><h3 id="简述工作流程"><a href="#简述工作流程" class="headerlink" title="简述工作流程"></a>简述工作流程</h3><ol><li>在 vue 组件里面，通过 dispatch 来触发 actions 提交修改数据的操作。</li><li>然后再通过 actions 的 commit 来触发 mutations 来修改数据。</li><li>mutations 接收到 commit 的请求，就会自动通过 Mutate 来修改 state<br>(数据中心里面的数据状态)里面的数据。 </li><li>最后由 store 触发每一个调用它的组件的更新</li></ol><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><ol><li><p>mapState： 对state的对象进行二次计算，他可以简化我们代码，这样我们获取cartList,不用写this.$store.state.cartList一大串了，尤其对于我们组件中用到次数挺多的情况下，我们完全可以用mapState来代替。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class="line">export default &#123;  </span><br><span class="line">    computed:mapState(&#123;  </span><br><span class="line">      cartList:state =&gt; state.cartList,</span><br><span class="line">      getCartList:&apos;cartList&apos;  //或者我们新定义一个参数，接受cartList,这样组件其他地方用到了,我们可以用this.getCartList来获取    </span><br><span class="line">   &#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapGetter：我们可以理解成他是和mapState一样，都是对state里面的参数进行计算，并返回相应的值，所以我们平常看到的mapState.mapGetters都是在computed属性里面，但是和mapState有点不同的是，mapState是仅对state里面的参数进行计算并返回，而mapGetters是对state参数派生出的属性进行计算缓存，比如计算state中cartList数组的长度或者对他的参数进行筛选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters&#125; from &apos;vuex&apos;</span><br><span class="line">// getters.js</span><br><span class="line">export default &#123;</span><br><span class="line">    getCartListLen: state =&gt;&#123;</span><br><span class="line">        return state.cartList.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 组件</span><br><span class="line">export default &#123;</span><br><span class="line">   computed:&#123;</span><br><span class="line">       mapGetters(&#123;</span><br><span class="line">            getLen:&apos;getCartListLen&apos;</span><br><span class="line">       &#125;),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapMutation：写在methods里面，因为他触发的是方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations&#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">   methods:&#123;</span><br><span class="line">      ...mapMutations([</span><br><span class="line">      &apos;add_cart&apos;, // 将 `this.add_cart()` 映射为 `this.$store.commit(&apos;add_cart&apos;)`</span><br><span class="line">    ]),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapAction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions&#125; from &apos;vuex&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">   methods:&#123;</span><br><span class="line">      ...mapActions([</span><br><span class="line">      &apos;add_cart&apos;, // 将 `this.add_cart()` 映射为 `this.$store.dispatch(&apos;add_cart&apos;)`</span><br><span class="line">    ]),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x基础知识</title>
      <link href="/2020/05/24/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/05/24/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="vue2-x生命周期"><a href="#vue2-x生命周期" class="headerlink" title="vue2.x生命周期"></a>vue2.x生命周期</h3><p><img src="/images/lifecycle.png" alt="avatar"></p><ul><li>beforeCreate ;&nbsp; &nbsp;//创建前状态，el和data并未初始化</li><li>created ;&nbsp; &nbsp;//创建完毕状态，完成了data数据的初始化，el没有</li><li>beforeMount ;&nbsp; &nbsp;//挂载前状态，完成了el和data初始化</li><li>mounted;&nbsp; &nbsp;//挂载后状态，完成挂载</li><li>beforeUpdate ;&nbsp; &nbsp; //更新前状态</li><li>updated ;&nbsp; &nbsp; //更新完成状态</li><li>beforeDestroy ;&nbsp; &nbsp; //销毁前状态</li><li>destroyed ;&nbsp; &nbsp;//销毁完成状态</li></ul><p>1.在beforeCreate和created钩子函数之间的生命周期，在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定。</p><p>2.created钩子函数和beforeMount间的生命周期，综合排名优先级:render函数选项 &gt; template选项 &gt; outer HTML。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>created:html加载完成之前，执行。执行顺序：父组件-子组件</li><li>mounted:html加载完成后执行。执行顺序：子组件-父组件</li><li>methods：事件方法执行</li><li>watch：是去监听一个值的变化，然后执行相对应的函数。</li><li>computed：是计算属性，有缓存功能，是依赖其它的属性计算所得出最后的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指向</title>
      <link href="/2020/01/14/this%E6%8C%87%E5%90%91/"/>
      <url>/2020/01/14/this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h3 id="This指向规则"><a href="#This指向规则" class="headerlink" title="This指向规则"></a>This指向规则</h3><p>This指向分为四种绑定规则：默认绑定、隐式绑定、显式绑定以及关键字new绑定。在ES6之后，又有了箭头函数中的this规则。</p><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; </span><br><span class="line">    console.log(this.bar); </span><br><span class="line">&#125; </span><br><span class="line">var bar = &quot;bar1&quot;; </span><br><span class="line">var o2 = &#123;bar: &quot;bar2&quot;, foo: foo&#125;; </span><br><span class="line">var o3 = &#123;bar: &quot;bar3&quot;, foo: foo&#125;; </span><br><span class="line"></span><br><span class="line">foo();            </span><br><span class="line">o2.foo();          </span><br><span class="line">foo.call(o3);</span><br></pre></td></tr></table></figure><p>三个函数调用分别输出：”bar1”, ”bar2”, ”bar3”。因此这三者分别是默认绑定、隐式绑定和显式绑定。</p><h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;Nicolas&apos;;</span><br><span class="line">function Person()&#123;</span><br><span class="line">    this.name = &apos;Smiley&apos;;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        console.log(this); </span><br><span class="line">        console.log(this.name); </span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(this.sayName, 0);     // 第二次输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">person.sayName();</span><br></pre></td></tr></table></figure><p>第一次输出的是Person, Smiley。第二次输出的结果是window，Nicolas。尽管setTimeout是在构造函数中定义的，但是调用的时候，是在window中调用。SetTimeout等许多之后被触发的事件当中，一定要注意this的指向，这是基于调用点（call stack）的 。</p><h4 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">  this.name = &quot;Smiley&quot;;</span><br><span class="line">  this.sayName = function()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name); </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person = new Person();</span><br><span class="line">let sayNameCopy = person.sayName;</span><br><span class="line">sayNameCopy();</span><br></pre></td></tr></table></figure><p>答案是window和undefined。因为，这个时候符合默认绑定的规则。</p><h4 id="实例四"><a href="#实例四" class="headerlink" title="实例四"></a>实例四</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">  this.name = &quot;Smiley&quot;;</span><br><span class="line">  this.sayName = ()=&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name); </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person = new Person();</span><br><span class="line">person.sayName.call(&#123;name: &quot;Nicolas&quot;&#125;);</span><br></pre></td></tr></table></figure><p>我们只改动了一处：把sayName改为箭头函数。结果则变成了Person和”Smiley”。这是因为箭头函数并没有自己的this，被定义在哪里，this就指向谁，且优先级比显式调用高，因此，this仍指向Person。</p><h4 id="实例五"><a href="#实例五" class="headerlink" title="实例五"></a>实例五</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">  this.age = 0;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(this.age);     // 输出undefined</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Person()&#123;</span><br><span class="line">  this.age = 10;</span><br><span class="line">  setTimeout(()=&gt; &#123;</span><br><span class="line">    console.log(this.age);     // 输出10</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure><p>在上面没有使用箭头函数的例子当中，setTimeout内部的函数是被global调用的，而global没有age这个属性，因此输出undefined。</p><p>第二个例子使用了箭头函数，this就会使用lexical scope中的this，就是Person，因此输出10。</p><h3 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h3><ol><li>箭头函数</li><li>关键字new调</li><li>显式绑定</li><li>隐式绑定</li><li>默认绑定</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angula r知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大同之行</title>
      <link href="/2019/07/09/%E5%A4%A7%E5%90%8C%E4%B9%8B%E8%A1%8C/"/>
      <url>/2019/07/09/%E5%A4%A7%E5%90%8C%E4%B9%8B%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="2019-7-6日星期六"><a href="#2019-7-6日星期六" class="headerlink" title="2019.7.6日星期六"></a>2019.7.6日星期六</h3><pre><code>1.悬空寺-凯歌火锅-华严寺-九龙壁-鼓楼-凤临阁-城墙</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凌晨四点从北京出发去大同，八点半到达第一站衡山脚下的悬空寺，温度16度，明明是夏天，真的是冷到打哆嗦，游玩一个半小时，开车两小时到达市区酒店，吃了当地有名的凯歌火锅，人均60吃到撑，服务员看我们剩的太多，打包了两盘肉，超级好吃的油条油饼，5块钱可以拼5个油瓶跟5个油条，便宜到不敢相信，吃好回酒店睡了会午觉。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下午第一站华严寺，因为我们几个人都没带现金，华严寺门票在携程上买好了，到了还要去换票，说是得两个小时之后才能进去，不得不找路人兑换现金，现场买票，下次一定要看清楚。寺院有个500平方米的千佛地宫，采用100吨纯铜打造而成，内供佛祖舍利及千尊佛像，金碧辉煌。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;九龙壁离华严寺很近，走路十多分钟，之前还有门票，现在免费，中国比较有代表性的九龙壁有故宫九龙壁、大同九龙壁和北海九龙壁，被称为中国“三大九龙壁”，虽然去过故宫两次，但是也没注意过。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凤临阁号称是装潢费超过三个亿，去过大同凤临阁，才理解什么叫“煤老板的奢华”，菜品也不是很贵，烧麦必点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼓楼就在一个十字路口点正中间，在外面观看免费,进楼需要10元门票，最后去了城墙，拿身份证免费进去，当天有个音乐节，人挺多，需要另外收费，我们到那已经快结束了，就在城墙溜达溜达，上去之后还有很多人在上面租自行车骑，吹着小风哼着歌，夜晚的景色还是很撩人。</p><pre><code>2.云冈石窟-凉粉-刀削面-买土特产-回京</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云冈石窟离市区还有一定的距离，有公交，打车也不贵，起步价7块，到目的地花了40多，因为是5A景点，有专业的讲解，去了只剩三级讲解员，收费120元，讲解时间大约一小时，要是我们自己肯定只是走马观花看一遍，什么也看不出来，游玩时间四个小时左右，保留最好，最好看的是第五、六窟，一个洞窟雕刻需要27年左右，推荐一个游记<a href="https://www.jianshu.com/p/00c201742249?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/00c201742249?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到市区下午一点多，吃了好吃的凉粉，坐汽车去县城摘杏，第一次看到跟桃一样大的杏，临出发又吃了一碗刀削面，这里多刀削面会加豆腐干，还可以加卤蛋，火腿还有肉丸，这边的特色还有羊杂汤，不知道为啥我会想起北京的卤煮，至今都没想吃。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次本来是想随便转转，走哪算哪，没想到成了深度游，跟一群志同道合的出去玩是一种享受！</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 山西大同 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数组方法</title>
      <link href="/2019/06/25/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/06/25/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="js常用数组方法"><a href="#js常用数组方法" class="headerlink" title="js常用数组方法"></a>js常用数组方法</h3><p>1.concat() 用于连接两个或多个数组。不改变原数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1,2,3];</span><br><span class="line">var arr2 = [4,5];</span><br><span class="line">var arr3 = arr1.concat(arr2);</span><br><span class="line">console.log(arr1); //[1, 2, 3]</span><br><span class="line">console.log(arr3); //[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p><p>2.join()用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用’,’号分割，不改变原数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,4];</span><br><span class="line">console.log(arr.join());  //&apos;2,3,4&apos; 长度为5</span><br><span class="line">console.log(arr);  //[2, 3, 4]</span><br></pre></td></tr></table></figure></p><p>3.push()向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [2,3,4];</span><br><span class="line">var b = a.push(5);</span><br><span class="line">console.log(a);  //[2,3,4,5]</span><br><span class="line">console.log(b);  //4</span><br></pre></td></tr></table></figure></p><p>4.pop()用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,4];</span><br><span class="line">console.log(arr.pop()); //4</span><br><span class="line">console.log(arr);  //[2,3]</span><br></pre></td></tr></table></figure></p><p>5.unshift()向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,4,5];</span><br><span class="line">console.log(arr.unshift(3,6)); //6</span><br><span class="line">console.log(arr); //[3, 6, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>6.shift()把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,4];</span><br><span class="line">console.log(arr.shift()); //2</span><br><span class="line">console.log(arr);  //[3,4]</span><br></pre></td></tr></table></figure><p>7.slice()返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,4,5];</span><br><span class="line">console.log(arr.slice(1,3));  //[3,4]</span><br><span class="line">console.log(arr);  //[2,3,4,5]</span><br></pre></td></tr></table></figure></p><p>8.splice(index,howmany,item)从数组中添加或删除元素，然后返回被删除的数组元素。 注：index表示从什么位置开始添加或删除数组元素，howmany表示删除的元素数量，如果为0，则表示不删除数组元素，item表示新增的数组元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [5,6,7,8];</span><br><span class="line">console.log(a.splice(1,0,9)); //[]</span><br><span class="line">console.log(a);  // [5, 9, 6, 7, 8]</span><br><span class="line">var b = [5,6,7,8];</span><br><span class="line">console.log(b.splice(1,2,3));  //[6, 7]</span><br><span class="line">console.log(b); //[5, 3, 8]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个人的韩国冒险</title>
      <link href="/2019/06/13/%E6%94%BB%E7%95%A5/"/>
      <url>/2019/06/13/%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>1.签证，淘宝找了一家400/次，五年三次的是800，一周出签。</p><p>2.提前一个月买机票，自己观察了四五天的价格，买的不是特价机票，但是也不是很贵，北京直飞首尔，往返两千左右，一定要看好自己所属的航空公司以及行李限重，韩亚航空可以一早值机，国航只能提前三小时，行李一定不能超重，会被重罚。</p><p>3.订酒店可以选爱彼邻或者携程的民宿还是有性价比高的民宿，自己英语不是很好，找了个中国房东，可以提供一些帮助。</p><p>4.准备转换插头。</p><p>5.兑换韩币，中国银行要提前一周预约，工商银行的话，部分网点可以兑换，也需要提前预约，之前换美金在招商银行当场就可以兑换的，在国内没兑换成，去银行多取点现金，可以在仁川机场兑换韩币，ATM或者人工，我是在机场兑换了10万韩币，折合人民币6百多点，扣了手续费，只够基本的交通费，大额一定要在明洞换（只能用现金），那边有很多私人换钱的，随便一家都比银行的汇率好。</p><p>6.租wifi，我是在携程环球漫游，网络很给力，电也够用，信用度高可以免押金，一定要看清是否是安检区内取还，我入境安检完才想起来没还Wi-Fi，打电话给客服，派了人过来取，服务很赞。</p><p>7.在出境的时候在日上订了一部分东西，出境的免税店东西很全，后悔订的少，其实你预定完，不用付钱，等回来提货的时候再付，不想要的也没事，买的眼精华入境的日上没有两件装，买的单瓶，足足比之前出境贵了一百。</p><p>8.在仁川机场的便利店办了tmoney的交通卡，可以坐地铁，机场大巴，公交，卡费四千韩币，充值四万韩币，足够四天的交通费（韩国地铁不用安检）。</p><p>9.出行地图，Naver，百度地图，我是两者结合用的。</p><p>10.出行地铁，韩国地铁APP。</p><p>11.首尔的景点逛几个就好，如果要去景福宫，可以租套韩服，就不需要门票，我是在小红书找了一家，免费做发型，两个小时1万5韩币，老板说晚一会没事，服务超级好。</p><p>12.购物的话去乐天，新罗，提前下载好app，看好自己要买的东西，可以网上下单，走的那天去机场取货，我是怕那天超重，所以大件本土的品牌可以当场提货，其他的只能去机场提货，购物的坑太多，数量越多折扣越多，还是代购买的划算，现在代购价格很透明，金卡打折，返点，代购都是靠这个挣点钱，因为自己买的量少，折扣很少，部分东西还不如在国内找代购帮忙买，FILA(斐乐)的鞋子能比国内便宜一半，这是我这次出来买到的最划算的。</p><p>13.退税，机场可以自助退税机器,也有人工退税。</p><p>14.携程在你出发前几天会给你发条短信，是你这次旅行的管家，有什么不懂的，找不到路，各种突发状况都可以问，这服务对于第一次去韩国玩的人来说超级贴心。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 韩国首尔攻略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混合式应用开发之Cordova+vue中的问题</title>
      <link href="/2019/06/03/%E6%B7%B7%E5%90%88%E5%BC%8F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B9%8BCordova-vue/"/>
      <url>/2019/06/03/%E6%B7%B7%E5%90%88%E5%BC%8F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B9%8BCordova-vue/</url>
      
        <content type="html"><![CDATA[<h3 id="node-环境升级到-v8-以上，node-sass-报错的解决方法"><a href="#node-环境升级到-v8-以上，node-sass-报错的解决方法" class="headerlink" title="node 环境升级到 v8^ 以上，node-sass 报错的解决方法"></a>node 环境升级到 v8^ 以上，node-sass 报错的解决方法</h3><ul><li>报错：Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 8.x</li><li>解决方法： 使用 npm rebuild node-sass，然后在更新一下npm update</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript面向对象(下)</title>
      <link href="/2019/05/26/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/"/>
      <url>/2019/05/26/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是包装对象"><a href="#什么是包装对象" class="headerlink" title="什么是包装对象"></a>什么是包装对象</h3><p>基本类型都有自己对应的包装对象：String、Number、Boolean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str=&apos;hello&apos;;</span><br><span class="line">str.charAt(0) // 基本类型会找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型，包装对象消失</span><br></pre></td></tr></table></figure><h3 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h3><p>实例对象与原型之间的连接，叫做原型链（<em>proto</em>）</p><h3 id="面向对象的一些属性和方法"><a href="#面向对象的一些属性和方法" class="headerlink" title="面向对象的一些属性和方法"></a>面向对象的一些属性和方法</h3><ul><li><p>hasOwnProperty()：看是不是对象自身下面是属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr=[];</span><br><span class="line">arr.num=10;</span><br><span class="line">Array.prototype.num2=20;</span><br><span class="line">console.log(arr.hasOwnProperty(&apos;num&apos;) //true</span><br><span class="line">console.log(arr.hasOwnProperty(&apos;num2&apos;) //false</span><br></pre></td></tr></table></figure></li><li><p>constructor：查看对象的构造函数</p><ol><li>每个原型都会自动添加constructor属性</li><li>for…in 的时候属性是找不到的</li><li>避免修改constructor属性</li></ol></li><li>instanceof：运算符，判断对象与构造函数在原型链上是否有关系</li><li>toString()：Object上的方法<ol><li>系统对象下的都是自带的，自己写的对象都是通过原型链找Object下的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr=[];</span><br><span class="line">console.log(arr.toString==Object.prototype.toString) //false</span><br><span class="line">function Aaa()&#123;&#125;</span><br><span class="line">var a1=new Aaa();</span><br><span class="line">console.log(a1.toString==Object.prototype.toString) //true</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>把对象转字符串</p></li><li><p>进制转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num=255</span><br><span class="line">console.log(num.toString(16)) //ff</span><br></pre></td></tr></table></figure></li><li><p>做类型判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var arr=[];</span><br><span class="line">console.log(Object.prototype.toString.call(arr)==&apos;[object Array]&apos;) //true</span><br><span class="line"> </span><br><span class="line">var arr1=new Date</span><br><span class="line">console.log(Object.prototype.toString.call(arr1)==&apos;[object Date]&apos;) //true</span><br><span class="line"> </span><br><span class="line">var arr1=new RegExp</span><br><span class="line">console.log(Object.prototype.toString.call(arr1)==&apos;[object RegExp]&apos;) //true</span><br><span class="line"></span><br><span class="line">var arr1=null</span><br><span class="line">console.log(Object.prototype.toString.call(arr1)==&apos;[object Null]&apos;) //true</span><br><span class="line"></span><br><span class="line">//遇到特殊iframe</span><br><span class="line">window.onload=function()&#123;</span><br><span class="line">   var oF=document.createElement(&apos;iframe&apos;);</span><br><span class="line">   document.body.appendChild(oF);</span><br><span class="line">   var ifArray=window.frames[0].Array;</span><br><span class="line">   var arr=new ifArray(); </span><br><span class="line">   // 判断是否为数组的三种方法，遇到iframe用toString()判断</span><br><span class="line">   console.log(arr.constructor==Array); //false</span><br><span class="line">   console.log(arr instanceOf Array );  //false</span><br><span class="line">   console.log(Object.prototype.toString.call(arr)==&apos;[object Array]&apos;) //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h3><ol><li>什么是继承<ul><li>在原有对象的基础上，略作修改，得到一个新的对象</li><li>不影响原有对象的功能</li></ul></li><li><p>如何添加继承</p><ul><li>属性：call 调用父类的构造函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function CreatePerson(name,sex)&#123; // 父类</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">CreatePerson.prototype.showName=function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var p1=new CreatePerson(&apos;小花&apos;,&apos;女&apos;)</span><br><span class="line">p1.showName()</span><br><span class="line">function CreateStar(name,sex,job)&#123; //子类</span><br><span class="line">    CreatePerson.call(this,name,sex); // 继承父类属性</span><br><span class="line">    this.job=job; </span><br><span class="line">&#125;</span><br><span class="line">extend(CreateStar.prototype,CreatePerson.prototype) // 继承方法</span><br><span class="line">var p2=new CreateStar(&apos;周杰伦&apos;,&apos;男&apos;,&apos;歌手&apos;)</span><br><span class="line">console.log(p2.showName())</span><br><span class="line">function extend(obj1,obj2)&#123;</span><br><span class="line">for(var attr in obj2)&#123;</span><br><span class="line">  obj1[attr]=obj2[attr]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法：for in （拷贝继承）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;name:&apos;小花&apos;&#125;;</span><br><span class="line">var b=&#123;&#125;;</span><br><span class="line">for (var attr in a)&#123;</span><br><span class="line">   b[attr]=a[attr]</span><br><span class="line">&#125;</span><br><span class="line">b.name=&apos;小绿&apos;</span><br><span class="line">console.log(a.name) // 小花，如果不使用for in做处理，返回小绿（堆栈）</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript面向对象(上)</title>
      <link href="/2019/05/21/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/05/21/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h3><ul><li>用对象的思想写代码，就是面向对象编程</li><li>一直使用的对象数组Array和时间Date</li></ul><h3 id="面向对象编程特点（OOP）"><a href="#面向对象编程特点（OOP）" class="headerlink" title="面向对象编程特点（OOP）"></a>面向对象编程特点（OOP）</h3><ul><li>抽象：抓住核心问题</li><li>封装：只能通过对象来访问方法</li><li>继承：从已有对象上继承出新的方法</li><li>多态：多对象的不同形态</li></ul><h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><ul><li>方法（行为、操作）</li><li>属性</li></ul><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ol><li><p>工厂方式（封装函数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createPerson()&#123;</span><br><span class="line">    var obj=new Object() // 原料</span><br><span class="line">    obj.name=name // 加工</span><br><span class="line">    obj.showName=fucntion()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">    return obj // 出厂  </span><br><span class="line">&#125;</span><br><span class="line">var p1=createPerson(&apos;小花&apos;).showName()</span><br><span class="line">var p2=createPerson(&apos;小林&apos;).showName()</span><br><span class="line">console.log(p1.showName==p2.showName) //false</span><br></pre></td></tr></table></figure></li><li><p>构造函数</p></li></ol><ul><li>当new去调用一个函数：这时候函数中当this就是创建出来当对象，而且函数的返回值直接就是this（隐式返回）</li><li><p>new后面的函数叫**构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function CreatePerson(name)&#123;</span><br><span class="line">    this.name=name</span><br><span class="line">    this.showName=fucntion()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1=new CreatePerson(&apos;小花&apos;).showName()</span><br><span class="line">p1.showName()</span><br><span class="line">var p2=new CreatePerson(&apos;小林&apos;).showName()</span><br><span class="line">p2.showName()</span><br><span class="line">console.log(p1.showName==p2.showName) //false</span><br></pre></td></tr></table></figure></li><li><p>构造函数之原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function CreatePerson()&#123;</span><br><span class="line">  this.name=name</span><br><span class="line">&#125;</span><br><span class="line">CreatePerson.prototype.showName=function()&#123;</span><br><span class="line">  alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var p1=new CreatePerson(&apos;小花&apos;).showName()</span><br><span class="line">var p2=new CreatePerson(&apos;小林&apos;).showName()</span><br><span class="line">console.log(p1.showName==p2.showName) //true</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><ul><li><p>对象类型：赋值不仅是值的复制，而且也是引用的传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=[1,2,3]</span><br><span class="line">var b=a</span><br><span class="line">b.push(4)</span><br><span class="line">console.log(b) //[1,2,3,4]</span><br><span class="line">console.log(a) //[1,2,3,4]</span><br></pre></td></tr></table></figure></li><li><p>例外</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=[1,2,3]</span><br><span class="line">var b=a</span><br><span class="line">b=[1,2,3,4]</span><br><span class="line">console.log(b) //[1,2,3,4]</span><br><span class="line">console.log(a) //[1,2,3]</span><br></pre></td></tr></table></figure></li><li><p>比较：对象类型值和引用都相同才为true</p><p>例1  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=[1,2,3]</span><br><span class="line">var b=[1,2,3]</span><br><span class="line">console.log(a===b) // false</span><br></pre></td></tr></table></figure><p>例2   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=[1,2,3]</span><br><span class="line">var b=a</span><br><span class="line">console.log(a===b) // true</span><br></pre></td></tr></table></figure></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li>去改写对象下面公用的方法和属性，让公用的方法或者属性在内存中存一份（提高性能）</li><li>原型中方法相当于css中的class，普通方法相当于css中的style</li><li><p>prototype 要写在构造函数的下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4]</span><br><span class="line">Array.prototype.sum=function()&#123;</span><br><span class="line">    var result=0;</span><br><span class="line">    for(var i=0;i&lt;this.length;i++)&#123;</span><br><span class="line">        result+=this[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return result </span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.sum()) // 10</span><br></pre></td></tr></table></figure></li><li><p>优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr=[];</span><br><span class="line">arr.number=10</span><br><span class="line">Array.prototype.number=20;</span><br><span class="line">console.log(arr.number) // 10 (style优先级高于class)</span><br></pre></td></tr></table></figure></li><li><p>写法以及使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function 构造函数()&#123;</span><br><span class="line">    this.属性</span><br><span class="line">&#125;</span><br><span class="line">构造函数.prototype.方法=fucntion()&#123;&#125;</span><br><span class="line">var 对象1=new 构造函数()</span><br><span class="line">对象1.方法()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>注释:解决了创建多个对象的问题,但是没有结解决对象识别的问题(怎样知道一个对象的类型)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.job = job;</span><br><span class="line">    obj.speak = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&apos;panrui&apos;,20,&apos;前端工程师&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>注释:没有显示的创建对象,没有返回语句,直接将属性赋给this对象,将Person的实例对象标识为一种特定的类型。缺点:每个方法在每个实例上面都需要重新定义一遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.speak = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;        </span><br><span class="line">&#125;</span><br><span class="line">var person2 = new Person(&apos;panrui&apos;,20,&apos;前端工程师&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>注意:省略了为构造函数传递初始化参数,结果所有实例享有相同的属性(对于函数实用,但是对于那些基本属性也说的过去,但是对于引用类型的数据就麻烦了)。基本属性我们可以在实例当中添加一个同名属性,这样可以隐藏原型当中的对应的属性,但是引用类型的属性却会导致所有实例共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &apos;panrui&apos;;</span><br><span class="line">Person.prototype.age = 23;</span><br><span class="line">Person.prototype.job = &apos;前端工程师&apos;;</span><br><span class="line">Person.prototype.speak = function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person3 = new Person()</span><br></pre></td></tr></table></figure></p><h3 id="组合使用构造函数与原型模式"><a href="#组合使用构造函数与原型模式" class="headerlink" title="组合使用构造函数与原型模式"></a>组合使用构造函数与原型模式</h3><p>构造函数用于定义实例属性,原型上面定义共享的属性和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.speak = function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person4 = new Person()</span><br></pre></td></tr></table></figure></p><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;    </span><br><span class="line">    if(typeof this.speak != &quot;function&quot;)&#123;</span><br><span class="line">        Person.speak = function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ant Design</title>
      <link href="/2019/05/15/antDesign/"/>
      <url>/2019/05/15/antDesign/</url>
      
        <content type="html"><![CDATA[<h2 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h2><h3 id="Input或Search组件设置默认值，设置不上的话可以使用-key-Math-random"><a href="#Input或Search组件设置默认值，设置不上的话可以使用-key-Math-random" class="headerlink" title="Input或Search组件设置默认值，设置不上的话可以使用 key={Math.random()}"></a>Input或Search组件设置默认值，设置不上的话可以使用 key={Math.random()}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Search</span><br><span class="line">    key=&#123;Math.random()&#125;</span><br><span class="line">    defaultValue= &#123;name&#125;</span><br><span class="line">    placeholder=&quot;按凭证名称搜索&quot;</span><br><span class="line">    style=&#123;&#123; width: 200 &#125;&#125;</span><br><span class="line">    onSearch=&#123;() =&gt; this.loadData(&#123; page: 1 &#125;)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3 id="修改placeholder样式"><a href="#修改placeholder样式" class="headerlink" title="修改placeholder样式"></a>修改placeholder样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder&#123;&#125;    /* 使用webkit内核的浏览器 */</span><br><span class="line">:-moz-placeholder&#123;&#125;                  /* Firefox版本4-18 */</span><br><span class="line">::-moz-placeholder&#123;&#125;                  /* Firefox版本19+ */</span><br><span class="line">:-ms-input-placeholder&#123;&#125;           /* IE浏览器 */</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// css设置</span><br><span class="line">.trace::-webkit-input-placeholder &#123;</span><br><span class="line">     color: rgba(255, 0, 0, 0.45);</span><br><span class="line">&#125;</span><br><span class="line">.trace:-moz-placeholder &#123;</span><br><span class="line">    color: rgba(255,0, 0, 0.45);</span><br><span class="line">&#125;</span><br><span class="line">.trace:-ms-input-placeholder &#123;</span><br><span class="line">    color: rgba(255,0, 0, 0.45);</span><br><span class="line">&#125;</span><br><span class="line">// 组件</span><br><span class="line"> &lt;Input placeholder=&quot;Trace ID&quot; className=&quot;trace&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ant Design </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
